# python-performance-practices

# Упражнение 00: List comprehensions
Сравнение производительности традиционного цикла с append и списковых включений для фильтрации email-адресов Gmail из списка.
Написание скрипта benchmark.py, который измеряет время выполнения обеих функций с помощью timeit и выводит, какой подход эффективнее, а также значения времени.

# Упражнение 01: Функция map()
Модификация скрипта benchmark.py из предыдущего упражнения.
Добавление функции, использующей map() (и list(map())) для той же задачи фильтрации email-адресов.
Сравнение производительности трех подходов: цикл, списковое включение и map().

# Упражнение 02: Функция filter()
Рефакторинг скрипта benchmark.py.
Добавление новой функции, использующей filter() для задачи фильтрации email-адресов.
Скрипт теперь принимает имя функции для тестирования (loop, list_comprehension, map, filter) и количество вызовов в качестве аргументов командной строки и выводит время выполнения.

# Упражнение 03: Функция reduce()
Написание скрипта benchmark.py для сравнения производительности вычисления суммы квадратов чисел до заданного значения.
Реализация двух функций: одна с использованием обычного цикла, другая — с использованием reduce() из модуля functools.
Скрипт принимает имя функции (loop или reduce), количество вызовов и число для расчета суммы квадратов в качестве аргументов и выводит время выполнения.

# Упражнение 04: Counter
Знакомство с классом Counter из модуля collections.
Написание скрипта benchmark.py, который:
Генерирует список из 1 000 000 случайных чисел от 0 до 100.
Реализует две пары функций:
Первая пара: создает словарь с подсчетом каждого числа (своя реализация и с Counter).
Вторая пара: находит топ-10 самых частых чисел (своя реализация и с Counter).
Сравнивает и выводит время выполнения для обоих подходов в каждой паре.

# Упражнение 05: Генераторы
Изучение влияния использования генераторов на потребление памяти и время выполнения при работе с большими файлами.
Загрузка датасета MovieLens (файл ratings.csv).
Создание двух скриптов:
ordinary.py: читает весь файл в список и итерируется по нему.
generator.py: использует генератор (yield) для чтения файла построчно и итерируется по генератору.
Оба скрипта должны выводить пиковое потребление памяти (в ГБ) и общее время (пользовательский режим + системный режим в секундах). Используются sys, resource (для Unix) или psutil (для Windows).
